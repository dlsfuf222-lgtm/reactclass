React Router가 브라우저의 **History API**를 왜 그렇게 집요하게(?) 사용하는지 이해하면
“라우터의 본질”을 훨씬 쉽게 이해할 수 있습니다. 😊


---

## 1. 먼저 큰 그림: SPA 라우팅 vs 전통적인 페이지 전환 🧠

전통적인 웹 사이트:

* `<a href="/about">` 클릭
* 브라우저가 **HTTP 요청**을 서버로 전송
* 서버가 **새 HTML 문서**를 응답
* 브라우저는 **기존 DOM을 날리고** 새 문서를 렌더링
* URL 변화 + 페이지 리로드가 한 세트

React + SPA(Single Page Application)에서 하고 싶은 것:

* URL은 `/`, `/about`, `/users/1` 같이 **여러 페이지처럼 보이게** 하고 싶다.
* 하지만 실제로는 **하나의 HTML**(`index.html`)만 로드하고,
  나머지는 **React가 클라이언트에서 화면만 갈아끼우는 방식**으로 처리하고 싶다.
* 즉:

  * **URL은 바뀌어야 하고** (북마크, 새로고침, 뒤로가기 등 지원)
  * **네트워크 전체 리로드는 피하고** (SPA의 핵심 장점)
  * 이 둘을 **분리**하고 싶다.

👉 이 “URL은 바꾸되, 페이지는 리로드하지 않는다”를 가능하게 해주는 브라우저 기능이 바로 **History API**입니다.

---

## 2. History API가 뭐길래? (pushState, replaceState, popstate) 📜

현대 브라우저는 다음과 같은 기능을 제공합니다:

* `history.pushState(state, '', url)`

  * URL을 **바꾸지만** 네트워크 요청 없이 **현재 문서(DOM)를 유지**
  * 브라우저의 **뒤로/앞으로 기록 스택**에 새로운 항목을 추가
* `history.replaceState(state, '', url)`

  * 현재 히스토리 항목을 **교체** (새 항목 추가 X)
* `window.onpopstate` / `window.addEventListener('popstate', ...)`

  * 사용자가 **뒤로가기/앞으로가기 버튼**을 눌렀을 때 호출되는 이벤트
  * 이 시점에 앱이 “아~ 지금 URL이 `/about`으로 돌아갔구나”를 알 수 있음

이 조합으로 할 수 있는 일:

* JS 코드에서:

  * `history.pushState(null, '', '/about')`
  * → 주소창은 `/about`으로 바뀜
  * → 페이지는 리로드되지 않음
  * → 뒤로가기 기록엔 `/about`이 추가됨
* 사용자가 뒤로가기 버튼 클릭:

  * `/about` → `/`
  * 브라우저가 `popstate` 이벤트 발생
  * SPA 라우터(React Router 등)가 **현재 URL에 맞는 컴포넌트를 다시 렌더링**

즉, History API는

> “**URL 타임라인을 조작하고 감지할 수 있는 리모컨**”
> 역할을 해줍니다. 🎮

---

## 3. React Router와 History API의 관계: 누가 누구를 쓰는가? 🧩

React Router의 핵심은 크게 보면 두 가지입니다:

1. **현재 URL을 상태처럼 “관찰”**
2. **URL이 바뀔 때마다 어떤 컴포넌트를 렌더링할지 결정**

이를 위해 React Router는 내부에서 **history 객체**를 다룹니다.
(예전 버전에서는 `history` 패키지를 직접 썼고, 지금도 개념은 비슷합니다.)

### 3.1. BrowserRouter가 하는 일

`<BrowserRouter>`는 내부적으로 대략 이런 일을 합니다 (개념적인 의사 코드):

```jsx
function BrowserRouter({ children }) {
  // 1. 현재 location(state)을 React state로 관리
  const [location, setLocation] = useState(window.location);

  // 2. 브라우저의 뒤로가기/앞으로가기(popstate) 이벤트를 구독
  useEffect(() => {
    const handlePopState = (event) => {
      // URL이 바뀌었으니, location을 업데이트
      setLocation(window.location);
    };

    window.addEventListener('popstate', handlePopState);
    return () => window.removeEventListener('popstate', handlePopState);
  }, []);

  // 3. 자식들에게 현재 location과 navigation 함수를 컨텍스트로 제공
  const routerContextValue = {
    location,
    navigate: (to, { replace } = {}) => {
      if (replace) {
        window.history.replaceState(null, '', to);
      } else {
        window.history.pushState(null, '', to);
      }
      // pushState/replaceState는 popstate를 발생시키지 않으므로 직접 업데이트
      setLocation(window.location);
    },
  };

  return (
    <RouterContext.Provider value={routerContextValue}>
      {children}
    </RouterContext.Provider>
  );
}
```

즉:

* `BrowserRouter`는

  * `history.pushState / replaceState`로 **URL을 조작**
  * `popstate` 이벤트로 **사용자 네비게이션 감지**
  * 이걸 React의 `useState` / `Context`와 엮어서

    * **리렌더링 트리거**로 사용합니다.

### 3.2. Link와 useNavigate가 하는 일

`<Link>`나 `useNavigate`는 내부적으로 이 `navigate` 함수를 쓰는 래퍼입니다.

```jsx
// 개념적 코드
function Link({ to, replace, ...rest }) {
  const { navigate } = useContext(RouterContext);

  const handleClick = (e) => {
    e.preventDefault(); // 기본 a 태그 네비게이션 막기
    navigate(to, { replace });
  };

  return <a href={to} onClick={handleClick} {...rest} />;
}
```

* `<a href>`를 그냥 쓰면:

  * 브라우저는 **전체 페이지 리로드**를 시도
* React Router의 `<Link>`는:

  * `e.preventDefault()`로 **기본 동작을 막고**
  * **History API를 이용해 URL만 변경**한 뒤
  * React state를 갱신 → **컴포넌트만 갈아끼움**

👉 이 패턴 때문에 React Router가 History API에 강하게 의존합니다.

---

## 4. 왜 굳이 History API를 써야 할까? (이유 정리) ✅

### 4.1. URL과 UI 상태를 동기화하기 위해 (State로서의 URL) 🌐

SPA에서 URL은 사실상 **앱의 상태**입니다.

* `/todos?filter=completed` → “완료된 TODO만 보고있는 상태”
* `/users/10` → “id가 10인 유저 상세를 보고 있는 상태”

History API를 사용하면:

* URL을 **직접 상태처럼 제어**할 수 있고
* URL의 변화에 따라 **UI를 리액티브하게 업데이트**할 수 있습니다.

React Router 입장에서:

* `location.pathname`, `location.search`는 **state**가 되고
* 이 state를 기준으로 `<Routes>` 안에서 어느 `<Route>`를 렌더링할지가 결정됨.

History API가 없다면:

* URL을 바꾸는 순간 **페이지 전체 리로드**가 발생
* SPA의 “상태 유지 + 부드러운 화면 전환”이라는 가치가 깨집니다.

---

### 4.2. 뒤로가기/앞으로가기 같은 브라우저 기본 UX 유지 🔙🔜

SPA라 해도 사용자는 여전히:

* 뒤로/앞으로 가기 버튼
* 새로고침
* 즐겨찾기/북마크
* 직접 주소창에 URL 입력

을 사용합니다.

History API를 사용하면:

* 공식적인 **브라우저 히스토리 스택**에 기록을 쌓게 되므로
* 사용자가 뒤로가기를 누르더라도

  * “앱 내부에서 UI만 갈아끼우는 방식”으로 대응 가능
  * 마치 정말 여러 페이지가 있는 것처럼 느껴짐

즉, 사용자는 SPA라는 사실을 거의 의식하지 않고
**기존 웹 UX 그대로** 쓸 수 있습니다. 🧑‍💻

---

### 4.3. SEO, 딥링크, 새로고침 호환성 🔗

History API 기반의 라우팅은:

* `/about`, `/users/1` 같은 **의미 있는 URL**을 만들 수 있고
* 사용자가 해당 URL을 브라우저에 직접 입력하거나
* 검색엔진/외부 서비스에서 링크를 타고 들어올 수 있습니다.

서버에서는:

* 어떤 URL이 들어와도 기본적으로 `index.html`을 반환하도록 설정 (SPA 서버 설정)
* 이후 React Router가 **클라이언트에서** URL을 보고 적절한 화면을 보여줌

이 구조 덕분에:

* 딥링크 (링크를 통한 특정 화면 직접 진입)
* 새로고침 시 같은 화면 유지
* SEO 최적화 (SSR/Static Generation과 조합 시)

가 훨씬 수월해집니다.

---

### 4.4. 해시 라우팅보다 더 자연스러운 URL (`#/` vs 실제 경로) 🆚

History API 이전에는 “해시 라우팅”이 많이 사용됐습니다.

* URL 예: `https://example.com/#/about`
* `#` 뒤의 값은 **서버에 전송되지 않고** 클라이언트에서만 해석
* `window.onhashchange` 이벤트로 변경 감지

하지만:

1. URL이 깔끔하지 않음 (`#/about` vs `/about`)
2. SEO, 공유, 서버 사이드 렌더링 환경에서 조금 더 불리
3. 브라우저 기록 처리도 History API만큼 세밀하지는 않음

React Router는:

* 일반적으로 `BrowserRouter` (History API 사용)를 권장
* 구형 서버 환경이나 특수 상황에서는 `HashRouter`를 제공

즉, History API는 **현대 SPA 라우팅의 정석**이고
해시 라우팅은 **폴백/특수 케이스**에 가깝습니다.

---

## 5. “History API 없으면 어떤 세상?” (대조를 통한 이해) 🔍

History API가 없다고 가정해 보면:

1. **Link 클릭 시**

   * `<a href="/about">` → 서버로 요청 → 새 HTML → 페이지 전체 리로드
   * React 앱 상태, 전역 스토어, 캐시, 스크롤 위치 등 모두 초기화

2. **뒤로 가기 시**

   * 이전 페이지 전체를 다시 서버에서 받아야 함

3. **라우팅 라이브러리의 역할 축소**

   * 클라이언트 라우팅 대신 서버 라우팅만 가능
   * React Router는 대부분의 기능을 잃어버림

게다가, SPA의 장점인:

* 빠른 화면 전환
* 클라이언트 상태 보존
* 네트워크 트래픽 감소

가 다 날아갑니다.
그래서 History API는 **SPA 라우터의 생명선**입니다. 🫀

---

## 6. 교수/강사 관점에서 “History API + React Router” 설명 팁 🎓

수업이나 강의 자료에 이런 흐름으로 넣으시면 좋습니다:

1. **전통적인 라우팅 그림**

   * `브라우저 → 서버 → HTML 응답 → 전체 리렌더`
   * URL 변할 때마다 서버 왕복

2. **SPA 라우팅 그림**

   * 처음 한 번만 `index.html` 로드
   * 이후엔 `React Router + History API`가

     * URL만 바꾸고
     * 컴포넌트만 교체

3. **코드 레벨 예시**

   ```jsx
   import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

   function App() {
     return (
       <BrowserRouter>
         <nav>
           <Link to="/">Home</Link>
           <Link to="/about">About</Link>
         </nav>

         <Routes>
           <Route path="/" element={<h1>Home</h1>} />
           <Route path="/about" element={<h1>About</h1>} />
         </Routes>
       </BrowserRouter>
     );
   }
   ```

   이 예제를 보여주고 나서:

   * `Link` 클릭 시 네트워크 탭에 **새 HTML 요청이 안 나가는 것**을 DevTools에서 보여주기
   * 주소창은 바뀌지만, 실제로는 **History API + React 렌더링**으로만 바뀌고 있음을 설명

4. **DevTools + Network + Performance로 시각화**

   * Network 탭에서 HTML 요청이 한 번만 나간다는 걸 보여주면 학생들이 직관적으로 이해 🔍

---

## 7. 정리: 왜 React Router는 History API를 사용하는가? 🧾

한 문장으로 요약하면:

> **React Router는 SPA에서 “URL 변화”를 “페이지 리로드 없이” 제어하고 감지하기 위해, 브라우저의 History API를 사용합니다.**

조금 더 풀면:

1. **URL과 UI 상태를 동기화**하기 위해
2. **뒤로/앞으로가기, 새로고침, 딥링크 등 브라우저 기본 UX**를 유지하기 위해
3. **SEO와 의미 있는 URL 구조**를 가지기 위해
4. 해시 라우팅보다 **더 자연스럽고 표준적인 방식**으로 라우팅하기 위해
5. 전체 페이지 리로드 없이 **부드러운 화면 전환**과 **상태 유지**를 하기 위해


