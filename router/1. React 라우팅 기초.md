# 🇰🇷✨ 리액트 라우팅 완전 정복 가이드 — “SPA 시대의 URL 매핑 엔진”

React Router로 이해하는 클라이언트 사이드 라우팅의 모든 것 🚀

리액트를 본격적으로 사용하게 되면 반드시 만나게 되는 개념이 바로 **라우팅(Routing)**입니다.
URL이 바뀌면 화면이 바뀌는 것이 너무 당연해 보이지만…
SPA(Single Page Application)에서는 이게 **절대 당연한 일이 아닙니다!**

---

# 🧭 1. 라우팅이란 무엇인가?

## 🔹 MPA 시대의 라우팅(전통 웹)

과거 웹(멀티 페이지 애플리케이션)은 다음과 같이 동작했습니다:

1. 사용자가 `/about` 클릭
2. 브라우저가 서버에게 **새 HTML 페이지 요청**
3. 서버가 `/about.html` 같은 문서를 내려줌
4. 브라우저 전체가 새로고침됨 (Full Refresh)

👉 라우팅의 주체는 **서버**였고, URL을 바꾸는 순간 **페이지 전체 리로드**가 발생했습니다.

---

## 🔹 SPA 시대의 라우팅

SPA는 **HTML 파일 딱 1개(index.html)**만 서버에서 받고,
이후의 모든 화면 전환은 **자바스크립트가 만든 가상 페이지에서 처리합니다.**

즉:

* `/home`, `/about` 등 **URL은 바뀌지만**
* 실제로는 브라우저가 **새 요청을 보내지 않음**
* 대신 React 앱이 내부적으로 **컴포넌트만 교체**

👉 라우팅의 주체가 **서버 → 클라이언트(=React)**로 이동함
👉 전체 새로고침이 없는 “부드러운 화면 전환” 가능

---

# 🧠 2. React Router가 필요한 이유

SPA는 브라우저 주소창에 `/about`을 입력하더라도 서버는 실제 `/about` 페이지를 갖고 있지 않습니다.

📌 그래서 React Router가 하는 일은?

* **URL을 가로채고(intercept)**
* 그 URL에 대해 어떤 React 컴포넌트를 렌더링할지 결정하며
* 브라우저 History(History API)를 이용해 경로를 변경합니다.

즉, React Router는 **“URL을 상태(state)로 사용하는 엔진”**입니다.

---

# 🧩 3. React Router 동작 원리 — History API ✨

React Router의 핵심은 **HTML5 History API**입니다:

* `history.pushState()`
* `history.replaceState()`
* `popstate` 이벤트

이 API를 이용하면 **백엔드 서버에게 해당 URI을 요청하지 않고도 해당 URI의 URL을 변경**할 수 있습니다.

예시:

```js
history.pushState({}, '', '/about')
```

📌 실행 결과:

* URL은 `/about`으로 변경됨
* 하지만 실제로는 네트워크 요청 X
* React Router가 이 변경을 감지하고 적절한 컴포넌트를 렌더링함

👉 이것이 바로 SPA에서 “깜빡임 없는 화면 전환”이 가능한 이유입니다.

---

# 🧱 4. React Router 기본 구성 요소 살펴보기

React Router v6 기준입니다.

## 4-1. BrowserRouter 🏠

브라우저의 히스토리를 관리하는 최상위 컴포넌트

```jsx
import { BrowserRouter } from "react-router-dom";

<BrowserRouter>
  <App />
</BrowserRouter>
```

역할:

* 어떤 URL이든 **전부 index.html로 우선 응답**
* 라우팅은 내부적으로 JS에서 처리

---

## 4-2. Routes + Route 🚏 컴포넌트 레지스트리

```jsx
import { Routes, Route } from 'react-router-dom';

<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/about" element={<About />} />
</Routes>
```

💡 특징:

* v6부터 “Switch” 대신 “Routes”
* `element`는 컴포넌트를 JSX로 전달해야 함 (컴포넌트 함수X)

---

## 4-3. Link 🔗

페이지 리로드 없이 이동시키는 컴포넌트

```jsx
<Link to="/about">About</Link>
```

👉 클릭해도 서버로 요청이 날아가지 않습니다.

---

## 4-4. useNavigate 🧭

자바스크립트에서 이동시켜야 할 때 사용

```jsx
const navigate = useNavigate();
navigate('/login');
```

---

# 🧩 5. 고급 라우팅: 중첩 라우팅(Nested Routes) 🔥

React Router의 핵심 기능 중 하나입니다.

## 디렉토리 구조 예:

```
/products
/products/:id
/products/:id/reviews
```

## 구현

```jsx
<Routes>
  <Route path="/products" element={<ProductsLayout />}>
    <Route index element={<ProductList />} />
    <Route path=":id" element={<ProductDetail />} />
    <Route path=":id/reviews" element={<ProductReviews />} />
  </Route>
</Routes>
```

그리고 `ProductsLayout` 안에서:

```jsx
import { Outlet } from "react-router-dom";

function ProductsLayout() {
  return (
    <div>
      <h1>상품 페이지</h1>
      <Outlet /> {/* 여기에 자식 라우트가 렌더링됨 */}
    </div>
  );
}
```

📌 장점:

* UI 구조를 라우트 구조와 일치시키기 용이
* 라우트 단위로 레이아웃 분리 가능

---

# 🎯 6. 동적 라우팅(Dynamic Routing)

URL의 일부를 변수처럼 사용하는 패턴:

예: `/products/10`, `/products/20`

```jsx
<Route path="/products/:id" element={<ProductDetail />} />
```

컴포넌트에서 가져오기:

```jsx
import { useParams } from 'react-router-dom';

const { id } = useParams();
```

---

# 🛡️ 7. 라우트 가드(Route Guard) — 인증 처리

SPA에서는 “페이지 이동 차단”도 직접 구현해야 합니다.

예시: 인증되지 않으면 `/login`으로 보내기

```jsx
function ProtectedRoute({ element }) {
  const isLoggedIn = !!localStorage.getItem('token');
  return isLoggedIn ? element : <Navigate to="/login" />;
}
```

사용:

```jsx
<Route path="/mypage" element={<ProtectedRoute element={<MyPage />} />} />
```

---

# ⚡ 8. 코드 스플리팅(지연 로딩) — 성능 개선

React Router는 `lazy()`와 함께 사용하면 매우 강력합니다.

```jsx
const About = React.lazy(() => import('./pages/About'));

<Route path="/about" element={
  <Suspense fallback={<Loading />}>
    <About />
  </Suspense>
} />
```

이렇게 하면:

* `/about` 페이지에 진입할 때만 해당 JS를 네트워크에서 받아옴
* 초기 로딩 속도 대폭 개선 🔥

---

# 🗺️ 9. 404 Not Found 처리

가장 마지막에 `*` 추가:

```jsx
<Route path="*" element={<NotFound />} />
```

---

# 🧱 10. 전체 라우팅 구조 예시

```jsx
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    
    <Route path="/products" element={<ProductsLayout />}>
      <Route index element={<ProductList />} />
      <Route path=":id" element={<ProductDetail />} />
    </Route>

    <Route path="/about" element={<About />} />
    <Route path="*" element={<NotFound />} />
  </Routes>
</BrowserRouter>
```

---

# 🎉 마무리 — 왜 React Router는 중요할까?

React Router는 단순히 URL을 바꾸는 도구가 아닙니다.
사실상 **앱 전체의 구조, 화면 흐름, 접근 권한, 네트워크 최적화**를 모두 포함하는 거대한 UI 엔진입니다.

✔️ SPA 시대의 필수 도구
✔️ URL을 상태로 사용하는 modern pattern
✔️ UI = URL 이라는 철학 기반
✔️ 성능(코드 스플리팅), 보안(가드), 구조(중첩 라우트)를 모두 해결

---

## 참고 사항 😃

* 📌 **Router Hooks(useLocation, useSearchParams 등) 완전 가이드**
* 📌 **Router v6.4 Data API(useLoaderData, useAction) 버전 설명**


