React.Suspense 완벽 가이드 🕰️
“로딩”을 다루는 리액트의 비밀 병기

---

## 1. Suspense는 도대체 뭘까? 🤔

한 줄 정의부터 볼게요.

> **React.Suspense는 “아직 준비 안 된 UI 조각”을 잠시 멈추고, 대신 `fallback` UI를 보여주는 경계(boundary) 컴포넌트입니다.**

조금 더 풀어서 말하면:

* 컴포넌트 트리의 **일부**가 아직 렌더링할 준비가 안 됐을 때
  (예: 코드 스플리팅된 컴포넌트를 아직 네트워크에서 못 받았거나, 데이터가 아직 안 온 경우)
* 그 부분이 **완료될 때까지** 특정 UI(`fallback`)로 “기다리는” 역할을 합니다.
* 준비가 끝나면 React가 자동으로 진짜 UI로 교체해 줍니다.

즉, **“이 아래 컴포넌트들이 준비될 때까지 이 UI로 버텨줘”** 라고 React에게 알려주는 경계입니다.

---

## 2. 가장 흔한 사용법: `React.lazy`와 함께 🐢

현재(React 18 기준) 공식 문서에서 “안전하게” 권장하는 Suspense 사용법은 사실상 **코드 스플리팅 + `React.lazy`** 입니다.

### 2.1 기본 예제

```jsx
// 1) 지연 로딩 컴포넌트 정의
import React, { Suspense } from 'react'

// 동적 import → Promise를 반환
const Profile = React.lazy(() => import('./Profile'))

export default function App() {
  return (
    <div>
      <h1>My App</h1>

      {/* 2) Suspense로 Profile 로딩 상태 제어 */}
      <Suspense fallback={<p>프로필 로딩 중...</p>}>
        <Profile />
      </Suspense>
    </div>
  )
}
```

렌더링 타임라인은 이렇게 흘러갑니다 ⏱️

1. `Profile`을 렌더링하려고 보니,
   `React.lazy`가 내부적으로 **“아직 로딩 중인 Promise”** 를 React에게 던짐(throw).
2. Suspense는 **“아, 자식 컴포넌트가 아직 준비 안 됐구나”** 를 감지.
3. 그 순간, React는 `Profile` 대신 `fallback` (`<p>프로필 로딩 중...</p>`)을 렌더링.
4. 동적 import가 끝나면(`Profile` 모듈 로드 완료),
5. React가 다시 렌더링 → 이때는 더 이상 Promise를 던지지 않음 → 진짜 `<Profile />` 렌더링.

핵심 포인트:

* **Suspense 경계 안의 자식 컴포넌트 중 누군가**
  “나 아직 준비 안 됐어” 라고 Promise를 던지면,
* React는 그 경계를 **통째로** “보류(pending)” 상태로 보고
  → `fallback`을 대신 렌더링합니다.

---

## 3. Suspense의 정신 모델 🧠

조금 추상적으로 표현하면, Suspense는 이렇게 동작합니다:

> **“자식 컴포넌트 중 누가 Promise를 던지면, 해당 경계를 잠시 멈추고 `fallback`을 보여준다. Promise가 해결되면 원래 UI로 바꿔치기한다.”**

이걸 “정신 모델”로 요약해 보면:

1. **렌더 단계에서의 Promise 탐지**

   * React는 렌더링 과정에서 컴포넌트들을 실행해 보다가,
   * 만약 어떤 컴포넌트가 **Promise를 throw** 하면,
   * “아, 이 컴포넌트는 아직 데이터를 못 받았거나, 코드를 못 받았구나”라고 판단.

2. **Suspense 경계까지 역추적**

   * React는 컴포넌트 트리를 타고 위로 올라가면서
     가장 가까운 `<Suspense>`를 찾습니다.

3. **해당 경계에 `fallback` 렌더링**

   * 그 경계 안의 실제 UI는 잠시 “보류” 상태로 두고,
   * 그 자리에 `fallback` UI를 렌더링합니다.

4. **Promise가 resolve되면 재렌더**

   * Promise가 해결된 시점에, React가 다시 렌더링 시도.
   * 이번에는 Promise를 던지지 않으니
     → 정상 UI가 그 자리를 차지합니다.

여기서 중요한 점 🔥

* Suspense는 **로딩 상태를 “상태값(state)”로 관리하지 않습니다.**
* 대신, **“Promise를 던지는 패턴”** 을 기반으로

  * 렌더링을 일시 정지
  * fallback으로 대체
  * 나중에 진짜 UI 복원
    를 수행합니다.

---

## 4. 여러 Suspense 경계 패턴 🧩

### 4.1 페이지 전체를 감싸는 경계

```jsx
<Suspense fallback={<PageSkeleton />}>
  <Page />
</Suspense>
```

* 장점: 구현이 간단
* 단점: 페이지 일부만 느려도 **전체 페이지가 통째로 로딩 상태**가 됨

### 4.2 섹션별로 나누는 경계 (권장) ✅

```jsx
export default function DashboardPage() {
  return (
    <div>
      <Suspense fallback={<SummarySkeleton />}>
        <SummarySection />
      </Suspense>

      <Suspense fallback={<ChartSkeleton />}>
        <ChartSection />
      </Suspense>

      <Suspense fallback={<ActivitySkeleton />}>
        <ActivitySection />
      </Suspense>
    </div>
  )
}
```

* 일부 섹션만 느려도 그 섹션만 “로딩” UI로 교체.
* 나머지 영역은 바로 보여줄 수 있어 **체감 속도**가 훨씬 좋습니다.

### 4.3 중첩 Suspense (Nested)

```jsx
<Suspense fallback={<PageSkeleton />}>
  <Header />
  <Suspense fallback={<SidebarSkeleton />}>
    <Sidebar />
  </Suspense>
  <MainContent />
</Suspense>
```

동작 규칙:

* **내부 경계가 우선**:

  * `Sidebar`가 느려도 `Header`, `MainContent`는 렌더링 가능하면 그대로 출력.
  * `Sidebar` 부분만 `SidebarSkeleton`으로 대체.
* **외부 경계는 “최후의 보루”**:

  * 전체 페이지 렌더링 중에 또 다른 Promise가 던져지면,
  * 그때는 바깥 `PageSkeleton`으로 전체를 덮을 수 있음.

---

## 5. Suspense와 데이터 패칭 📡

중요한 사실 하나:

> **React는 “데이터 패칭용 Suspense”를 공식 스펙으로는 아직 완전히 독립 제공하지 않고, 주로 프레임워크(Next.js, Remix, Relay 등)를 통해서 사용하게 유도합니다.**

그럼에도 불구하고, **개념을 이해하는 것**은 매우 중요합니다.
(교육할 때 특히요 👍)

### 5.1 “Promise를 던지는 리소스” 패턴 (학습용)

아래 코드는 **“실전에서는 이렇게 직접 쓰지 마세요”**에 가깝지만,
Suspense의 동작 원리를 이해하기에는 최고의 예시입니다.

```jsx
// fakeApi.js
function wrapPromise(promise) {
  let status = 'pending'
  let result

  const suspender = promise.then(
    (value) => {
      status = 'success'
      result = value
    },
    (error) => {
      status = 'error'
      result = error
    }
  )

  return {
    read() {
      if (status === 'pending') {
        throw suspender          // ✅ Suspense가 잡아낼 Promise
      } else if (status === 'error') {
        throw result             // ✅ Error Boundary가 잡을 에러
      } else if (status === 'success') {
        return result            // ✅ 준비 완료된 데이터
      }
    },
  }
}

// “리소스” 생성
export function fetchUserResource(userId) {
  const userPromise = fetch(`/api/users/${userId}`).then((res) => res.json())
  return {
    user: wrapPromise(userPromise),
  }
}
```

이제 컴포넌트에서 이렇게 사용합니다:

```jsx
// UserProfile.jsx
import React, { Suspense } from 'react'
import { fetchUserResource } from './fakeApi'

const resource = fetchUserResource(1)

function UserDetails() {
  const user = resource.user.read() // ❗ 여기서 필요 시 Promise를 throw
  return (
    <div>
      <h2>{user.name}</h2>
      <p>email: {user.email}</p>
    </div>
  )
}

export default function Page() {
  return (
    <Suspense fallback={<p>사용자 정보 로딩 중...</p>}>
      <UserDetails />
    </Suspense>
  )
}
```

렌더 흐름:

1. `UserDetails` 렌더링 시 `resource.user.read()` 호출
2. 아직 `status === 'pending'` 이면 → `throw suspender`
3. 상위 `Suspense`가 이를 감지 → `fallback` 렌더링
4. Promise가 resolve → React가 다시 렌더 → 이번엔 `status === 'success'` →
   `user` 데이터 반환 → 실제 UI 렌더링

이 패턴이 바로 **“Suspense for Data Fetching”**의 **정신 모델**입니다.
실전에서는 이 역할을 **Next.js의 fetch 래핑, Relay, React Server Components 등**이 대신 담당합니다.

---

## 6. Suspense와 Concurrent Features (React 18) ⚙️

React 18에서 도입된 **Concurrent Rendering**과 함께 보면 Suspense의 의미가 더 또렷해집니다.

### 6.1 `startTransition`과 함께 사용

```jsx
import { useState, startTransition, Suspense } from 'react'
import SearchResult from './SearchResult'

export default function SearchPage() {
  const [query, setQuery] = useState('react')

  const handleChange = (e) => {
    const value = e.target.value
    setQuery(value) // 기본 상태 업데이트

    // 좀 “무거운” 검색 결과 렌더링은 우선순위를 낮춰서 처리
    startTransition(() => {
      setQuery(value)
    })
  }

  return (
    <div>
      <input onChange={handleChange} />
      <Suspense fallback={<p>검색 중...</p>}>
        <SearchResult query={query} />
      </Suspense>
    </div>
  )
}
```

아이디어:

* **사용자 입력(타이핑)** 은 고우선순위.
* 그에 따라 발생하는 **무거운 UI 업데이트(검색 결과 렌더링)** 는 저우선순위.
* `startTransition`으로 감싼 쪽이 Suspense와 함께 **부드럽게 전환**될 수 있습니다.

### 6.2 `useDeferredValue`와 함께

```jsx
const deferredQuery = useDeferredValue(query)
```

* 사용자가 입력하는 `query`는 바로바로 바뀌지만,
* `deferredQuery`는 약간 “지연된” 값.
* `deferredQuery`를 사용해서 Suspense 기반 검색 결과를 렌더링하면,

  * 타이핑은 즉각 반응,
  * 검색 결과는 한 박자 늦게, 그리고 로딩 상태를 깔끔하게 보여줄 수 있습니다.

---

## 7. `SuspenseList` – 여러 Suspense를 조율하기 🎻

페이지 안에 여러 Suspense 경계가 있을 때,
각자 따로따로 로딩/완료되면 UI가 우르르 바뀌면서 **깜빡이는 느낌**을 줄 수 있습니다.

`SuspenseList`는 이런 경우를 조율하는 도구입니다.

```jsx
import { Suspense, SuspenseList } from 'react'

export default function Dashboard() {
  return (
    <SuspenseList revealOrder="forwards">
      <Suspense fallback={<CardSkeleton />}>
        <Card type="summary" />
      </Suspense>

      <Suspense fallback={<CardSkeleton />}>
        <Card type="chart" />
      </Suspense>

      <Suspense fallback={<CardSkeleton />}>
        <Card type="activity" />
      </Suspense>
    </SuspenseList>
  )
}
```

`revealOrder` 옵션:

* `"together"`: 모두 준비될 때 한 번에 보여줌.
* `"forwards"`: 위에서부터 순서대로 준비되는 대로 보여줌.
* `"backwards"`: 아래에서부터 순서대로.

의미:

* 사용자에게 UI가 **“어디서부터 채워지는지”** 일관된 느낌을 줍니다.
* 특히 카드 리스트나 대시보드에서 체감 UX가 꽤 개선됩니다.

---

## 8. Suspense vs Error Boundary ⚠️

둘 다 “경계(boundary)”라는 점은 같지만, 역할은 완전히 다릅니다.

| 비교 항목      | Suspense 🕰️                | Error Boundary 🚨        |
| ---------- | --------------------------- | ------------------------ |
| 목적         | **로딩 중** 상태를 다룸             | **에러 발생** 상태를 다룸         |
| 트리거        | 자식이 **Promise를 throw** 할 때  | 자식이 **에러를 throw** 할 때    |
| 보여주는 것     | `fallback` (로딩 스피너, 스켈레톤 등) | 에러 메시지, 대체 UI            |
| 동시에 사용 가능? | ✅ 예, 같이 중첩해서 쓰는 패턴이 일반적     | ✅ Suspense 안/밖 어디든 사용 가능 |

실전 패턴:

```jsx
<Suspense fallback={<Spinner />}>
  <ErrorBoundary fallback={<ErrorMessage />}>
    <UserProfile />
  </ErrorBoundary>
</Suspense>
```

* 데이터 로딩 중 → `Spinner`
* 데이터 요청 실패(예: 500 에러) → `ErrorMessage`

---

## 9. SSR과 Streaming에서의 Suspense 🌊

React 18의 **Streaming SSR**과 만났을 때 Suspense는 더욱 빛을 발합니다.

아이디어:

1. 서버에서 HTML을 스트리밍으로 내려보내면서,
2. 아직 준비 안 된 부분은 `<Suspense fallback=...>`에 있는 **로딩 UI**로 먼저 보내고,
3. 준비가 되면 해당 부분만 클라이언트로 추가 스트림을 보내 **부분 교체**.

이걸 프레임워크 측면에서 보면:

* **Next.js App Router** (`app/` 디렉터리)에서
  `loading.js`, `Suspense` 등을 이용해

  * 서버 컴포넌트의 로딩 상태를 매우 정교하게 컨트롤.
* 사용자는 “페이지가 늦게 나오는 게 아니라 → 페이지가 점점 채워지는 느낌”을 받습니다.

핵심은:

> **Suspense는 클라이언트 렌더링 뿐 아니라, 서버 스트리밍 렌더링에서도 동일한 정신 모델로 동작한다.**
> “준비 안 된 부분은 fallback으로 버티고, 준비되면 실제 UI로 교체한다.”

---

## 10. 실전에서의 베스트 프랙티스 ✅

마지막으로, 교안/기술블로그에 꼭 넣을 만한 **실전 팁** 정리입니다.

1. **앱 전체를 하나의 Suspense로 감싸지 말 것**

   * 일부가 느리다고 전체를 로딩 스피너로 덮으면 UX가 나빠집니다.
   * 섹션별, 카드별 등 **작은 단위**로 잘라서 사용하세요.

2. **스켈레톤 UI를 적극 활용**

   * 단순한 “로딩중…” 텍스트보다
   * 스켈레톤(회색 박스) 레이아웃이 체감 속도를 훨씬 좋게 만듭니다.

3. **데이터 패칭용 Suspense는 프레임워크 + 공식 가이드를 따를 것**

   * 직접 Promise를 던지는 “리소스 패턴”은 **개념 설명/연습용**으로는 아주 좋지만,
   * 실제 앱에서는 Next.js, Relay, Remix 등 **프레임워크가 제공하는 방식**을 따라가는 게 안전합니다.

4. **Error Boundary와 함께 세트로 운용**

   * “로딩 중”과 “에러 발생”을 각각 Suspense와 ErrorBoundary에 맡기면,
   * 코드 구조가 매우 명확해집니다.

5. **Concurrent Feature와 함께 생각**

   * `startTransition`, `useDeferredValue`와 같이,
   * **“어떤 업데이트가 급하고, 어떤 건 느려도 되는가?”** 를 설계하면
   * Suspense가 진짜 힘을 발휘합니다.

---

## 11. 요약 🌟

* `React.Suspense`는 **“아직 준비 안 된 UI를 잠시 멈추고, 대신 fallback을 보여주는 경계”** 입니다.
* 현재 가장 공식적인 사용처는 **코드 스플리팅 + `React.lazy`**.
* 내부적으로는 **“Promise를 던지는 패턴”** 을 이용해 로딩 상태를 관리합니다.
* 섹션별, 중첩, SuspenseList 등으로 섬세하게 UX를 제어할 수 있습니다.
* 데이터 패칭, Concurrent Rendering, Streaming SSR과 결합하면

  * **“점진적 렌더링”** 을 자연스럽게 구현할 수 있습니다.


