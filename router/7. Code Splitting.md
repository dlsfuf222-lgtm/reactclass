코드 스플리팅(Code Splitting)은 한 줄로 말하면,

> **“자바스크립트 코드를 한 덩어리로 뭉치지 말고, 필요할 때 필요한 것만 나눠서 가져오는 기술”** 입니다. 🚚📦

React.lazy()를 이해하셨으면, 사실 이미 코드 스플리팅의 핵심을 한 번 지나가신 거예요.
이번에는 “코드 스플리팅” 자체를 **도구/프레임워크에 종속되지 않는 개념**으로 정리해 보겠습니다. 

---

## 1. 왜 코드 스플리팅이 필요해졌나? 🤔

### 1) 예전 웹 vs 요즘 웹

옛날 웹(멀티 페이지, MPA)

* `/index.html` → `index.js`
* `/about.html` → `about.js`
* `/admin.html` → `admin.js`
* 페이지마다 JS 파일이 따로 있었습니다.

요즘 웹(SPA, React/Vue)

* `/index.html` 하나에
* `bundle.js` 하나가 **앱 전체 코드를 다 들고 있음**
  → `Home`, `About`, `Admin`, `Dashboard`, `Chart`, `Editor` … 전부 한 번에 다운로드

### 2) 문제: 번들 비대화 📦⬆️

앱이 커질수록:

* 초기 번들 크기 ↑

  * 500KB → 1MB → 2MB…
* 초기 로딩(TTFB + 다운로드 + 파싱 + 실행) 시간이 길어짐
* 유저는 **“홈 화면만 보려고 들어왔는데, 안 쓰는 Admin/Chart 코드까지 다 받아야 하는 상황”**

→ 결국 **초기 로딩 속도가 UX/SEO를 망가뜨리는 주범**이 됩니다.

그래서 등장한 전략이 바로 **코드 스플리팅(Code Splitting)** 입니다.

---

## 2. 코드 스플리팅이란 정확히 뭐냐? 🧩

정의적으로는:

> “번들링 과정에서 코드를 여러 개의 작은 청크(chunk)로 나누고,
> 런타임에는 필요할 때만 그 청크들을 네트워크로 가져오는 것”

조금 더 개발자 관점에서 풀면:

1. 빌드 시:

   * 번들러가 **모듈 그래프**를 분석합니다.
   * “여기서부터는 나중에 필요할 수 있어”라고 표시된 지점을 기준으로 코드를 여러 파일로 나눔.
2. 실행 시:

   * 유저가 해당 기능/페이지에 들어갈 때
   * 그 때 필요한 JS 청크만 네트워크로 가져와서 실행

결과:

* 초기에는 **핵심만** 작은 번들로 빠르게 로드 ⚡
* 나머지는 유저 행동에 따라 **게으르게(lazy) 다운로드** ⏳

---

## 3. 번들(bundle)과 청크(chunk) 이해하기 📦➡️🧱

### 3.1. 번들(bundle)

* 개발자는 수십~수백 개의 JS 파일(`.js`, `.jsx`, `.ts`, `.tsx`)을 작성
* 번들러(Webpack, Vite, Rollup 등)는 이것들을 한/몇 개의 파일로 묶음

  * 예: `assets/index-8sdf3.js`
* 이 묶음 파일을 **번들(bundle)** 이라고 합니다.

### 3.2. 청크(chunk)

코드 스플리팅 후에는:

* `index-8sdf3.js` (초기 로딩용)
* `AdminPage-2a1c0.js` (관리자 페이지)
* `Chart-92b1f.js` (차트 페이지)
* `Editor-ff99d.js` (에디터 기능)

처럼 여러 개로 나뉩니다. 이 **나눠진 조각**을 **청크(chunk)** 라고 부릅니다.

**정리하자면:**

* 번들링 전: 수많은 모듈 파일들
* 번들링 후 (코드 스플리팅 전): 1~몇 개의 번들
* 번들링 후 (코드 스플리팅 후): 여러 개의 번들을 쪼갠 청크들

---

## 4. 코드 스플리팅이 언제/어떻게 일어나는가? ⛓️

실제로 “어디를 기준으로” 나눌까요? 대표적인 패턴은 아래 4가지입니다.

### 4.1. 엔트리 포인트 기반 스플리팅 (Multi Entry) 🔑

예전/특정 구조에서는:

```js
// Webpack 예시
module.exports = {
  entry: {
    main: './src/main.js',
    admin: './src/admin.js',
  },
}
```

* `main.js`와 `admin.js`를 각각 엔트리로 지정
* 빌드 결과:

  * `main-xxxx.js`
  * `admin-xxxx.js`

→ 전통적인 “페이지별 JS 파일” 구조와 비슷한 개념.

SPA에서는 요즘은 이런 방식보다 **dynamic import 기반**이 더 일반적입니다.

---

### 4.2. dynamic import (`import()`) 기반 스플리팅 🧠

ES2020에 추가된 **dynamic import**가 코드 스플리팅의 핵심입니다.

#### 4.2.1. 일반 import vs dynamic import

```js
// 정적 import (static import)
import { heavyFunction } from './heavy-module.js'
```

* 번들러는 이걸 보고

  * “heavy-module은 항상 필요하구나”
  * → 초기 번들에 무조건 포함

```js
// 동적 import (dynamic import)
button.addEventListener('click', async () => {
  const module = await import('./heavy-module.js')
  module.heavyFunction()
})
```

* 번들러는 이걸 보고

  * “이 모듈은 런타임에 조건에 따라 필요하겠구나”
  * → 별도 청크로 분리 (예: `heavy-module-xxx.js`)
* 런타임에는 `import()`가 호출되었을 때 **네트워크로 해당 청크를 요청**

#### 4.2.2. 순수 JS 버전 예제 (React 없이)

```html
<button id="chart-btn">차트 보기</button>
<div id="chart-container"></div>

<script type="module">
  const btn = document.getElementById('chart-btn')
  btn.addEventListener('click', async () => {
    const { renderChart } = await import('./chart.js')
    renderChart(document.getElementById('chart-container'))
  })
</script>
```

* 초기 로딩 시:

  * `chart.js`는 다운로드되지 않음 → 초기 번들 가벼움
* 버튼 클릭 시:

  * `import('./chart.js')` 실행
  * network: `chart-xxx.js` 청크 요청
  * 다운로드 완료 후 `renderChart()` 실행 → 차트 렌더

이게 바로 **코드 스플리팅의 기본 원리**입니다.

---

### 4.3. React에서의 코드 스플리팅: React.lazy() + Suspense ⚛️

React에서는 dynamic import 패턴을 더 쓰기 좋게 해주는 도우미가 **React.lazy**입니다.

```jsx
import React, { Suspense } from 'react'

const AdminPage = React.lazy(() => import('./AdminPage'))

export default function App() {
  return (
    <Suspense fallback={<p>관리자 페이지 로딩 중...</p>}>
      <AdminPage />
    </Suspense>
  )
}
```

* `React.lazy(() => import('./AdminPage'))`

  * dynamic import를 사용하는 지점이 곧 “스플릿 포인트(split point)”
* 번들러:

  * `AdminPage`를 별도 청크로 분리
* 런타임:

  * `<AdminPage />`가 렌더링되는 순간 청크 요청
  * 로딩 끝날 때까지 Suspense가 fallback UI 렌더

**React Router와 함께 쓰면**:

* 라우트마다 lazy 컴포넌트 → **페이지 단위 코드 스플리팅**
* `/admin` 페이지 진입 시에만 `AdminPage` 청크 로드

---

### 4.4. Vendor / Library 코드 분리 (벤더 스플리팅) 📚

실무에서 자주 보는 `vendor` 청크:

* React, ReactDOM, lodash, axios 같은 **라이브러리들**
* 애플리케이션 코드와 분리해서 하나의 청크로 묶는 전략

이렇게 하면:

1. 라이브러리 코드는 자주 안 바뀜
2. 애플리케이션 코드만 바뀔 때:

   * 앱 청크만 캐시 무효화
   * vendor 청크는 브라우저 캐시에 그대로 남아 있음
3. 유저 입장:

   * 첫 방문 이후에는 **재방문/라우터 전환이 훨씬 빠름**

Vite/Webpack에서는 플러그인/설정으로 이 vendor 그룹을 자동/수동으로 나누게 할 수 있습니다.

---

## 5. 코드 스플리팅의 장점 ✅

### 5.1. 초기 로딩(First Load) 시간 단축 ⏱️

* SPA의 최대 단점 중 하나: 첫 페이지 로딩이 오래 걸림
* 코드 스플리팅으로 “필수 코드”만 먼저 로딩
* 나머지는 유저가 실제로 해당 기능을 사용할 때 로딩

→ TTI(Time To Interactive)를 줄이고, “앱이 빨라 보이는 느낌”을 줍니다.

### 5.2. 네트워크/리소스 효율 ⛽

* 유저가 **절대 가지 않는 페이지**의 코드는 평생 다운로드되지 않을 수도 있음

  * 예: `Admin`, `SuperUser`, `DebugPanel` 등
* 모바일/저속 네트워크 환경에서 특히 유리

### 5.3. 캐싱 전략 최적화 ♻️

* 코어 로직, 라우트 별 페이지, 라이브러리 등을 나눔으로써

  * **자주 바뀌는 것**과 **거의 안 바뀌는 것**을 분리
* 브라우저 캐시 사용을 극대화 → 재방문 속도 향상

---

## 6. 코드 스플리팅의 단점/트레이드오프 ⚖️

### 6.1. 네트워크 요청 수 증가 🌐

* 파일이 쪼개졌다는 것은

  * HTTP 요청이 많아진다는 뜻
* HTTP/2/HTTP/3 환경에서는 병렬 요청에 유리하지만

  * 여전히 요청이 너무 많으면 성능에 악영향 가능

→ “적당히” 나누는 설계가 중요합니다.

### 6.2. 런타임 복잡성 증가 🧩

* 코드가 “항상 있다”는 전제를 버려야 합니다.

  * 로딩 중 상태 고려
  * 로딩 실패(네트워크 에러) 고려
* React에서는 Suspense + ErrorBoundary 패턴이 사실상 필수

### 6.3. UX 설계의 문제 😵‍💫

* 잘못 설계하면:

  * 페이지 이동할 때마다 스피너만 잔뜩 보이는 앱이 될 수 있음
* “언제 로딩을 보여줄지, 어느 정도까지만 쪼갤지” 설계가 필요

---

## 7. 어디를 기준으로 나누는 것이 좋을까? 🎯 (베스트 프랙티스)

현업에서 많이 쓰는 기준 몇 가지를 정리해 보겠습니다.

### 7.1. 라우트(Route) 단위 스플리팅

가장 많이 쓰는 전략입니다.

* `/`, `/login`, `/dashboard`, `/admin`, `/settings`…
* 각 라우트 컴포넌트를 lazy 로딩

**장점**

* 개념적으로 명확: “페이지 = 청크”
* UX 측면에서도 자연스러움

  * 사용자가 페이지 이동 시 **살짝 로딩**은 기대 가능한 동작

### 7.2. 기능(Feature) 단위 스플리팅

특정 기능이 **매우 무거울 때**:

* 예: 리치 텍스트 에디터, 차트 라이브러리, 맵(Map) 컴포넌트 등

```jsx
const RichEditor = React.lazy(() => import('./RichEditor'))
const Chart = React.lazy(() => import('./Chart'))
```

* 사용자가 실제로 “에디터 열기”, “차트 보기”를 눌렀을 때만 로딩
* 관리자 전용, 통계 페이지 전용 기능에도 적합

### 7.3. 역할(Role) / 영역(Domain) 단위 스플리팅

* 일반 사용자 영역 vs 관리자(Admin) 영역
* B2B 앱에서 “특정 고객/부서만 사용하는 기능” 같은 곳

→ “거의 안 쓰는 무거운 영역”을 통째로 잘라내서 lazy 로딩하는 전략

---

## 8. “너무 많이 쪼갠다”는 건 어떤 상태일까? 🪓

과도한 코드 스플리팅의 징후:

* 페이지 하나에 진입했는데

  * 작은 컴포넌트마다 스피너가 돌아감
* 네트워크 탭을 보면

  * 자잘한 JS 파일을 수십 개씩 요청

이럴 경우:

1. 특정 페이지 내에서는

   * 주요 기능들은 하나의 청크에 묶어두고
   * 진짜 무거운 것만 추가로 분리
2. 라우트 레벨 Suspense를 사용해

   * “페이지 전체로서” 로딩 상태를 보여주도록 설계

→ 사용자 입장에서는 **“페이지 하나당 한 번 정도 로딩이 보이면 적당”**한 경우가 많습니다.

---

## 9. 프리패치(Prefetch) / 프리로드(Preload)로 UX 끌어올리기 🚀

코드 스플리팅만 하면 “로딩 딜레이”가 생깁니다.
이를 줄이기 위한 전략이 **prefetch / preload** 입니다.

### 9.1. 예시: 마우스를 올렸을 때 미리 로드

```jsx
const AdminPage = React.lazy(() => import('./AdminPage'))

function preloadAdmin() {
  import('./AdminPage')
}

export default function App() {
  const [open, setOpen] = useState(false)

  return (
    <>
      <button
        onMouseEnter={preloadAdmin}
        onFocus={preloadAdmin}
        onClick={() => setOpen(true)}
      >
        Admin 열기
      </button>

      <Suspense fallback={<p>Admin 로딩중...</p>}>
        {open && <AdminPage />}
      </Suspense>
    </>
  )
}
```

* 사용자가 버튼에 마우스를 올리는 순간

  * 백그라운드에서 이미 청크를 받아오기 시작
* 실제 클릭 시에는 대부분 로딩이 끝나 있어서

  * fallback이 거의 안 보이거나 아주 잠깐만 보임

### 9.2. `<link rel="prefetch">`, `<link rel="preload">`

* HTML `<head>`에 미리 다음 청크를 프리패치/프리로드하는 링크 삽입
* Vite/Webpack도 dynamic import에 주석 등을 달아서 이 동작을 유도할 수 있습니다. (예: webpack magic comment)

---

## 10. “번들링” vs “코드 스플리팅” vs “트리 쉐이킹” 🌳

헷갈릴 수 있는 개념들을 정리해 보면:

* **번들링(Bundling)**
  → 여러 모듈을 하나/여러 개의 파일로 합치는 것
* **코드 스플리팅(Code Splitting)**
  → 그 번들을 “여러 개의 청크로 나눠서 필요할 때 로드”하는 전략
* **트리 쉐이킹(Tree Shaking)**
  → 사용하지 않는(unused) 코드를 번들에서 제거하는 최적화

즉,

1. 트리 쉐이킹으로 “쓸데없는 가지”를 떨궈내고 🌳✂️
2. 번들링으로 필요한 코드들을 묶고 📦
3. 코드 스플리팅으로 여럿으로 쪼개서 필요할 때 나눠 가져옵니다 🧱🧱🧱

---

## 11. 정리: 코드 스플리팅을 한 문장으로 설명한다면? ✍️

**강의/블로그용 한 줄 정리:**

> 코드 스플리팅은 SPA에서 비대해진 자바스크립트 번들을
> 여러 개의 작은 청크로 나누고, 사용자의 행동(라우팅, 버튼 클릭 등)에 따라
> 해당 청크를 그때그때 네트워크로 가져오는 성능 최적화 기법이다. ⚡

**핵심 포인트 다시 한 번:**

1. **문제**: SPA 번들 비대화 → 초기 로딩 느림
2. **도구**: 번들러 + dynamic import (`import()`)
3. **전략**:

   * 라우트 기반
   * 기능/위젯 기반
   * 권한/도메인 기반
   * vendor 분리
4. **실무 패턴**:

   * React.lazy() + Suspense
   * React Router에서 라우트 단위 lazy
   * 프리패치/프리로드로 UX 개선
5. **트레이드오프**:

   * 네트워크 요청 수 증가
   * 로딩 상태/에러 상태 처리 필요
   * 적절한 스플리팅 경계 설계 필요


