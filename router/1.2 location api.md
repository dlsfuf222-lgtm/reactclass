# 🧭 `window.location` : 브라우저 URL을 다루는 핵심 객체

React Router나 SPA를 설명할 때 **History API**와 함께 반드시 등장하는 개념이 있습니다.
바로 브라우저가 현재 “어디에 있는지”를 나타내는 객체, **`window.location`**입니다.

하지만 많은 개발자들이 이 객체를
“그냥 URL 문자열을 가진 객체 정도?”라고만 알고 넘어가는 경우가 많습니다.

사실 `window.location`은 **페이지 이동, 리다이렉트, 새로고침, URL 파싱, 프로토콜 관리** 등
웹 애플리케이션 동작의 중심에 있는 굉장히 중요한 인터페이스입니다.

이번 글에서는 `window.location`이 **정확히 어떤 역할을 하는지**,
그리고 왜 React Router가 이 객체를 **직접 제어하지 않고 History API를 선택하는지**까지 논리적으로 연결해서 설명합니다.

---

# 1. `window.location`은 무엇인가? 🌐

`window.location`(혹은 `document.location`)은 현재 문서의 **전체 URL 정보를 담고 있는 객체**입니다.

예를 들어 브라우저 주소창이 다음과 같다고 해봅시다:

```
https://example.com:443/users?id=10#bio
```

`window.location`은 이 URL을 다음처럼 자동으로 **세부 파트로 분해하여 속성으로 제공**합니다:

| 속성         | 의미                         | 예시 값                                    |
| ---------- | -------------------------- | --------------------------------------- |
| `href`     | 전체 URL                     | `"https://example.com/users?id=10#bio"` |
| `protocol` | 프로토콜                       | `"https:"`                              |
| `host`     | 호스트 + 포트                   | `"example.com:443"`                     |
| `hostname` | 호스트 이름                     | `"example.com"`                         |
| `port`     | 포트                         | `"443"`                                 |
| `pathname` | 경로                         | `"/users"`                              |
| `search`   | 쿼리스트링                      | `"?id=10"`                              |
| `hash`     | 해시                         | `"#bio"`                                |
| `origin`   | protocol + hostname + port | `"https://example.com"`                 |

즉, `window.location`은 URL을 구성하는 모든 정보를 **객체 형태로 쉽게 접근 가능**하게 해줍니다.
이는 **URL 파싱을 직접 하지 않아도 된다**는 강력한 이점이 있습니다.

---

# 2. `window.location`이 할 수 있는 일들 ⚙️

## 📌 2.1. URL 읽기 (현재 페이지 정보 확인)

가장 기본적인 쓰임새입니다:

```js
console.log(window.location.pathname); // '/users'
console.log(window.location.search);   // '?id=10'
```

SPA 라우터가 없는 환경에서
“지금 어디 페이지인지 파악해야 할 때”는 무조건 이 객체로 확인합니다.

---

## 📌 2.2. 페이지 이동 (리다이렉트)

`window.location.href`에 값을 대입하면 **강제 페이지 이동(전체 리로드)**이 일어납니다.

```js
window.location.href = '/login';
```

혹은:

```js
window.location.assign('/login');
```

둘 다 **새로운 페이지로 완전히 이동**하며
SPA가 아닌 “전통적인 페이지 이동 방식”을 사용합니다.

---

## 📌 2.3. 페이지를 교체(replace)

뒤로가기로 돌아오지 못하도록 현재 페이지를 덮어쓰기:

```js
window.location.replace('/login');
```

로그인 만료 시 자주 사용됩니다.

---

## 📌 2.4. 현재 페이지 새로고침

```js
window.location.reload();
```

이 역시 전통적인 전체 새로고침입니다.

---

## 📌 2.5. 해시 변화만 감지하기

해시(`#something`)가 바뀌면 페이지 리로드 없이 변경됨:

```js
window.location.hash = '#section1';
```

그리고 감지는:

```js
window.addEventListener('hashchange', () => {
  console.log('Hash changed:', window.location.hash);
});
```

이 방식이 과거 SPA의 “해시 라우팅”이 탄생한 이유입니다.
(React Router의 `HashRouter`가 이 방식 활용)

---

# 3. `window.location`의 *큰 한계*: 페이지 리로드가 발생한다 😱

여기서 SPA(예: React Router 등장 전/초기)에 치명적인 문제가 하나 생깁니다:

> `window.location.href = '/about'`
> **→ URL이 바뀜**
> **→ 페이지 전체 리로드 발생** 🤯

SPA는 페이지 전체를 다시 로딩하면 **앱 상태(State)**가 모두 사라지고
설명하신 History API 중심 아키텍처와 어긋납니다.

즉:

* 상태 관리 불가
* 컴포넌트 트리 초기화
* 네트워크 비용 증가
* 스크롤/폼 값 초기화
* 전체 렌더링 비용 증가

그래서 **React Router는 `window.location`을 직접 변경하지 않습니다.**

---

# 4. SPA가 `window.location`을 그대로 쓰지 않는 이유 🔥

SPA는 “URL은 바꾸지만 전체 리로드는 막고 싶다”는 요구를 가집니다.

하지만 `window.location`을 수정하면:

| 동작                         | 페이지 리로드 여부          |
| -------------------------- | ------------------- |
| `location.href = '/x'`     | ❌ 무조건 리로드됨          |
| `location.assign('/x')`    | ❌ 리로드됨              |
| `location.replace('/x')`   | ❌ 리로드됨              |
| `location.pathname = '/x'` | ❌ 리로드됨              |
| `location.hash = '#y'`     | ⭕ 리로드 없음 (단 해시만 변경) |

이 때문에:

* URL 변경 + 리로드 억제 기능이 필요한 SPA에서는
  **History API의 pushState/replaceState**가 필수입니다.

정리하면:

> `window.location`은 “문서 주소”를 의미
> → 수정 시 “문서 전체 리로드”가 기본 동작
> → SPA에 부적합

이에 반해:

> History API의 `pushState()`는
> → URL만 바꾸고 문서를 유지
> → SPA 라우팅에 최적화

---

# 5. React Router에서 `window.location`은 어디에 쓰일까? 🧩

React Router는 `window.location`을 **직접 수정하지는 않지만**,
이 객체를 **상태(location state)로 삼고**, 관찰합니다.

### React Router는 두 가지 상황에서 사용합니다:

---

## 📌 *1) 초기 마운트 시 현재 URL 읽기*

React 앱이 처음 뜰 때:

```jsx
const [location, setLocation] = useState(window.location);
```

(개념적 코드)

---

## 📌 *2) popstate 이벤트 발생 시 변경된 URL 읽기*

뒤로가기/앞으로가기 버튼을 누르면:

```jsx
window.addEventListener('popstate', () => {
  setLocation(window.location);
});
```

즉:

* `window.location`은 **현재 브라우저 주소를 읽는 역할**
* `history.pushState`는 **주소를 바꾸는 역할**

전자는 “읽기”,
후자는 “쓰기”로 구분됩니다.

SPA는 이들 **둘을 조합해서** 라우팅 동작을 구현합니다.

---

# 6. `window.location` vs History API 비교 표 📊

| 기능                 | `window.location` | `history.pushState` | SPA 적합성         |
| ------------------ | ----------------- | ------------------- | --------------- |
| URL 변경             | 가능                | 가능                  | 둘 다 가능          |
| 페이지 리로드            | 무조건 발생            | 발생하지 않음             | ⭐ pushState 승리  |
| 뒤로가기 스택 기록         | 있음                | 있음                  | 둘 다 OK          |
| UI 상태 보존           | 불가능               | 가능                  | ⭐ pushState 필수  |
| 해시 라우팅             | 가능                | 가능                  | 부분              |
| React Router 사용 여부 | ❌ 직접쓰면 안됨         | ⭕ 필수                | React Router 핵심 |

---

# 7. 요약: `window.location`의 역할과 한계 🧾

### ✔ `window.location`은

* 현재 URL을 읽고
* 전체 페이지 이동을 수행하며
* 새로고침/리다이렉트/해시 이동 등
  “전통적인 웹 내비게이션”을 담당합니다.

### ✔ 하지만 SPA에서 치명적인 단점:

* URL 변경 시 **항상 전체 리로드가 발생**
* 앱 상태가 모두 날아감
* SPA의 부드러운 화면 전환, 상태 유지라는 장점을 잃음

### ✔ 그래서 React Router는

* **URL 읽기 → `window.location`**
* **URL 쓰기(조작) → History API (pushState/replaceState)**
* **뒤로가기 감지 → popstate 이벤트**

이 조합으로 SPA 경험을 제공합니다.

---

# 🔚 결론:

React Router와 같은 SPA 라우터는

> `window.location`은 읽기 전용으로 사용하고
> History API를 통해 URL을 “리로드 없이 조작”하는 전략을 택합니다.

그래야만:

* SPA의 부드러운 전환
* URL 기반 상태 관리
* 브라우저 기본 UX 지원
* 딥링크/새로고침 호환
* 서버 사이드 렌더링 및 SEO 확장성

모두 확보할 수 있기 때문입니다. 🚀


